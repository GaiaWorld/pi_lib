// #![feature(generators, generator_trait)]

/**
 * 写时复制的sbtree，支持单线程或多线程安全
 */

use std::option::Option;
use std::cmp::{Ord, Ordering};
use std::rc::Rc;
//use std::ops::{Generator, GeneratorState};
// use std::sync::Arc;
// use std::fmt::{Display, Formatter, Result};
pub enum ActionResult<T> {
	Ignore,
	Enter(T),
	Delete,
}

#[derive(Copy)]
pub struct Entry<K, V> {
	key: K,
	value: V,
}
impl<K: Clone, V: Clone> Entry<K, V> {
	fn new(k: K, v: V) -> Self {
		Entry {
			key: k,
			value: v,
		}
	}
	pub fn key(&self) -> &K {
		&self.key
	}
	pub fn value(&self) -> &V {
		&self.value
	}
}
impl<K: Clone, V: Clone> Clone for Entry<K, V> {
    fn clone(&self) -> Self {
		Entry {
			key: self.key.clone(),
			value: self.value.clone(),
		}
	}
}
pub trait SBTree<K, V> {
	fn new() -> Self;
	//fn from_order(Vec<Entry<K, V>>) -> Self;
	fn is_empty(&self) -> bool;
	fn size(&self) -> usize;
	fn has(&self, &K) -> bool;
	fn get(&self, &K) -> Option<&V>;
	fn min(&self) -> Option<&Entry<K, V>>;
	fn max(&self) -> Option<&Entry<K, V>>;
	fn rank(&self, &K) -> isize;
	fn index(&self, usize) -> Option<&Entry<K, V>>;
	// fn keys(&self, Option<&K>) -> Generator;
	//fn values(&self, Option<&K>) -> gen;
	//fn entrys(&self, Option<&K>) -> gen;
	fn select<F>(&self, Option<&K>, &mut F) where F: FnMut(&Entry<K, V>);

	// fn insert(&mut self, K, V) -> bool;
	// fn update(&mut self, K, V, bool) -> Option<Option<V>>;
	//fn enter(&mut self, K, V, bool) -> Option<Option<V>>;
	// fn action(&mut self, K, Fn) -> Option<&V>;
	// fn map(&mut self, Fn) -> usize;
	//fn delete(&mut self, &K, bool) ->Option<Option<V>>;
	//fn remove(&mut self, usize, bool) -> Option<Option<&Entry<K, V>>>;
	//fn pop_min(&mut self, bool) -> Option<Option<&Entry<K, V>>>;
	//fn pop_max(&mut self, bool) -> Option<Option<&Entry<K, V>>>;

}


pub struct NSBTree<K, V> {
	root: Ref<K, V>,
}

// impl<K: Ord+Clone, V: Clone>  Display for NSBTree {
// 	fn fmt(&self, f: &mut Formatter) -> Result;
// }

impl<K: Ord+Clone, V: Clone> SBTree<K, V> for NSBTree<K, V> {
	/**
	 * 新建
	 */
	fn new() -> Self {
		NSBTree {
		  root: None,
		}
	}
	/**
	 * 判空
	 */
	fn is_empty(&self) -> bool {
		match &self.root {
		  &None => true,
		  _ => false,
		}
	}
	/**
	 * 获取指定树的大小
	 */
	fn size(&self) -> usize {
		match &self.root {
		  &Some(ref x) => {
			  (*x).1
		  },
		  _ => 0,
		}
	}
	/**
	 * 检查指定的Key在树中是否存在
	 */
	fn has(&self, key: &K) -> bool {
		match &self.root {
		  &Some(ref x) => (*x).has(key),
		  _ => false,
		}
	}
	/**
	 * 获取指定Key在树中的值
	 */
	fn get(&self, key: &K) -> Option<&V> {
		match &self.root {
		  &Some(ref x) => (*x).get(key),
		  _ => None,
		}
	}
	/**
	 * 获取树中最小的键值对
	 */
	fn min(&self) -> Option<&Entry<K, V>> {
		match &self.root {
		  &Some(ref x) => Some((*x).min()),
		  _ => None,
		}
	}
	/**
	 * 获取树中最大的键值对
	 */
	fn max(&self) -> Option<&Entry<K, V>> {
		match &self.root {
		  &Some(ref x) => Some((*x).max()),
		  _ => None,
		}
	}
	/**
	 * 获取指定Key在树中的排名，0表示空树，1表示第一名，负数表示没有该key，排名比该排名小
	 */
	fn rank(&self, key: &K) -> isize {
		match &self.root {
		  &Some(ref x) => (*x).rank(key),
		  _ => 0,
		}
	}
	/**
	 * 获取指定排名的键值，必须从1开始，如果超过最大排名，则返回None
	 */
	fn index(&self, i: usize) -> Option<&Entry<K, V>> {
		if i == 0 {
			return None;
		}
		if i == 1 {
			return self.min();
		}
		match &self.root {
			&Some(ref x) => {
				if i < (*x).1 {
					Some((*x).index(i - 1))
				} else if i > (*x).1 {
					None
				} else {
					Some((*x).max())
				}
			}
		  _ => None,
		}
	}
	// /**
	//  * 返回从指定键开始的键迭代器，如果不指定键，则从最小键开始
	//  */
	// // fn keys(&self, key: Option<&K>) -> Generator {
	// // 	let mut gen = || {
	// // 		yield 1;
	// // 		return "foo"
    // // 	};
	// // 	match gen.resume() {
	// // 		GeneratorState::Yielded(1) => {}
	// // 		_ => panic!("unexpected return from resume"),
	// // 	}
	// // 	match gen.resume() {
	// // 		GeneratorState::Complete("foo") => {}
	// // 		_ => panic!("unexpected return from resume"),
	// // 	}
	// // 	gen
	// // }
	/**
	 * 选择器方法，从指定键开始进行选择，如果不指定键，则从最小键开始
	 */
	fn select<F>(&self, key: Option<&K>, func: &mut F) where F: FnMut(&Entry<K, V>) {
		match &self.root {
			&Some(ref x) => {
				match key {
					Some(ref k) => (*x).select_key(k, func),
					_ => (*x).select(func),
				}
			},
			_ => (),
		}
	}
	// /**
	//  *  插入一个新的键值对(不允许插入存在的key)
	//  */
	// fn insert(&mut self, key: K, value: V) -> bool {
	// 	let r = match &self.root {
	// 		&Some(ref x) => (*x).insert(key, value),
	// 		_ => Some(Rc::new(Node(Entry::new(key, value), 1, None, None))),
	// 	};
	// 	match r {
	// 		None => false,
	// 		_ => {
	// 			self.root = r;
	// 			true
	// 		},
	// 	}
	// }
	// /**
	//  *  插入一个新的键值对(不允许插入存在的key)
	//  */
	// fn update(&mut self, key: K, value: V, copy: bool) -> Option<Option<V>> {
	// 	let r = match &self.root {
	// 		&Some(ref x) => (*x).update(key, value, copy),
	// 		_ => None,
	// 	};
	// 	match r {
	// 		Some((v, n)) => {
	// 			self.root = Some(n);
	// 			Some(v)
	// 		},
	// 		_ => None,
	// 	}
	// }

}

//====================================
type Ref<K, V> = Option<Rc<Node<K, V>>>;
struct Node<K, V>(Entry<K, V>, usize, Ref<K, V>, Ref<K, V>);

// struct Node<K, V> {
// 	size: usize,
// 	entry: Entry<K, V>,
// 	left: Ref<K, V>,
// 	right: Ref<K, V>,
// }

impl<K: Ord+Clone, V: Clone> Node<K, V> {
	
	// 迭代查找
	//#[inline]
	fn has(&self, key: &K) -> bool {
		let mut node = self;
		loop {
			match key.cmp(&node.0.key) {
				Ordering::Greater => match node.3 {
					Some(ref x) => node = &(*x),
					_ => break,
				},
				Ordering::Less => match node.2 {
					Some(ref x) => node = &(*x),
					_ => break,
				},
				_ => {
					return true;
				},
			}
		}
		return false;
	}
	// 迭代查找
	//#[inline]
	fn get(&self, key: &K) -> Option<&V> {
		let mut node = self;
		loop {
			match key.cmp(&node.0.key) {
				Ordering::Greater => match node.3 {
					Some(ref x) => node = &(*x),
					_ => break,
				},
				Ordering::Less => match node.2 {
					Some(ref x) => node = &(*x),
					_ => break,
				},
				_ => {
					return Some(&node.0.value);
				},
			}
		}
		return None;
	}
	// 迭代查找
	//#[inline]
	fn min(&self) -> &Entry<K, V> {
		let mut node = self;
		loop {
			match node.2 {
				Some(ref x) => node = &(*x),
				_ => break,
			}
		}
		return &node.0;
	}
	// 迭代查找
	//#[inline]
	fn max(&self) -> &Entry<K, V> {
		let mut node = self;
		loop {
			match node.3 {
				Some(ref x) => node = &(*x),
				_ => break,
			}
		}
		return &node.0;
	}
	// // 迭代查找
	// //#[inline]
	fn rank(&self, key: &K) -> isize {
		let mut node = self;
		let mut c: isize = 1;
		loop {
			match key.cmp(&node.0.key) {
				Ordering::Greater => {
					match node.2 {
						Some(ref x) => c += ((*x).1 as isize) + 1,
						_ => c += 1,
					};
					match node.3 {
						Some(ref x) => node = &(*x),
						_ => break,
					}
				},
				Ordering::Less => match node.2 {
					Some(ref x) => node = &(*x),
					_ => break,
				},
				_ => match node.2 {
					Some(ref x) => return ((*x).1 as isize) + c,
					_ => return c,
				},
			}
		}
		return -c;
	}
	// 迭代查找
	//#[inline]
	fn index(&self, i: usize) -> &Entry<K, V> {
		let mut node = self;
		let mut j = i;
		loop {
			match node.2 {
				Some(ref x) =>{
					let c = (*x).1;
					if j > c {
						j -= c + 1;
						match node.3 {
							Some(ref x) => node = &(*x),
							_ => break,
						}
					}else if j < c {
						node = &(*x);
					}else{
						break;
					}
				},
				None => {
					if j == 0 {
						break;
					}
					j -= 1;
					match node.3 {
						Some(ref x) => node = &(*x),
						_ => break,
					}
				},
			}
		}
		return &node.0;
	}
	fn select_key<F>(&self, key: &K, func: &mut F) where F: FnMut(&Entry<K, V>) {

	}
	fn select<F>(_, ref e, ref left, ref right)::Node(usize, Entry<K, V>, Ref<K, V>, Ref<K, V>), func: &mut F) where F: FnMut(&Entry<K, V>) {
		match left {
			&Some(ref x) => (*x).select(func),
			_ => ()
		};
		func(&self.entry);
		match self.right {
			Some(ref x) => (*x).select(func),
			_ => ()
		};
	}
	// // 递归插入
	// fn insert(&self, key: K, value: V) -> Option<Rc<Self>> {
	// 	if self.entry.key < key {
	// 		match self.right {
	// 			Some(ref x) => {
	// 				let r = (*x).insert(key, value);
	// 				match r {
	// 					None => return None,
	// 					_ => (),
	// 				};
	// 				Some(Self::maintain_right(self.entry.clone(), self.size + 1, &self.left, &r))
	// 			},
	// 			_ => Some(Rc::new(Node(self.entry.clone(), self.size + 1, None, Some(Rc::new(Node(Entry::new(key, value), 1, None, None)))))),
	// 		}
	// 	} else if self.entry.key > key {
	// 		match self.left {
	// 			Some(ref x) => {
	// 				let r = (*x).insert(key, value);
	// 				match r {
	// 					None => return None,
	// 					_ => (),
	// 				};
	// 				Some(Self::maintain_left(self.entry.clone(), self.size + 1, &r, &self.right))
	// 			},
	// 			_ => Some(Rc::new(Node(self.entry.clone(), self.size + 1, Some(Rc::new(Node(Entry::new(key, value), 1, None, None))), None))),
	// 		}
	// 	} else {
	// 		None
	// 	}
	// }
	// // 递归更新
	// fn update(&self, key: K, value: V, copy: bool) -> Option<(Option<V>, Rc<Self>)> {
	// 	if self.entry.key < key {
	// 		match self.right {
	// 			Some(ref x) => {
	// 				match (*x).update(key, value, copy) {
	// 					Some((v, r)) => Some((v, Rc::new(Node(self.entry.clone(), self.size, self.left.clone(), Some(r))))),
	// 					_ => None,
	// 				}
	// 			},
	// 			_ => None,
	// 		}
	// 	} else if self.entry.key > key {
	// 		match self.left {
	// 			Some(ref x) => {
	// 				match (*x).update(key, value, copy) {
	// 					Some((v, r)) => Some((v, Rc::new(Node(self.entry.clone(), self.size, Some(r), self.right.clone())))),
	// 					_ => None,
	// 				}
	// 			},
	// 			_ => None,
	// 		}
	// 	} else if copy {
	// 		Some((Some(self.entry.value.clone()), Rc::new(Node(Entry::new(key, value), self.size, self.left.clone(), self.right.clone()))))
	// 	} else {
	// 		Some((None, Rc::new(Node(Entry::new(key, value), self.size, self.left.clone(), self.right.clone()))))
	// 	}
	// }

	// // 节点左旋
	// //#[inline]
	// fn left_ratote (e: Entry<K, V>, size: usize, left: &Option<Rc<Self>>, right: &Self) -> Self {
	// 	let lsize = match left {
	// 		&Some(ref x) => (*x).size,
	// 		_ => 0,
	// 	};
	// 	let rsize = match right.left {
	// 		Some(ref x) => (*x).size,
	// 		_ => 0,
	// 	};
	// 	Node(right.entry.clone(), size, Some(Rc::new(Node(e, lsize + rsize + 1, left.clone(), right.left.clone()))), right.right.clone())
	// }

	// // 节点右旋
	// //#[inline]
	// fn right_ratote (e: Entry<K, V>, size: usize, left: &Self, right: &Option<Rc<Self>>) -> Self {
	// 	let rsize = match right {
	// 		&Some(ref x) => (*x).size,
	// 		_ => 0,
	// 	};
	// 	let lsize = match left.right {
	// 		Some(ref x) => (*x).size,
	// 		_ => 0,
	// 	};
	// 	Node(left.entry.clone(), size, left.left.clone(), Some(Rc::new(Node(e, lsize + rsize + 1, left.right.clone(), right.clone()))))
	// }
	// //Maintain操作，Maintain(T)用于修复以T为根的 SBT。调用Maintain(T)的前提条件是T的子树都已经是SBT。
	// // 左节点增加大小，Maintain操作
	// //#[inline]
	// fn maintain_left (e: Entry<K, V>, size: usize, left: &Option<Rc<Self>>, right: &Option<Rc<Self>>) -> Rc<Self> {
	// 	match right {
	// 		&Some(ref x) => {
	// 			match left {
	// 				&Some(ref y) => {
	// 					match (*y).left {
	// 						Some(ref z) if (*z).size > (*x).size => return Rc::new(Self::right_ratote(e, size, &*y, right)),
	// 						_ => (),
	// 					};
	// 					match (*y).right {
	// 						Some(ref z) if (*z).size > (*x).size => {
	// 							return Rc::new(Self::right_ratote(e, size, &Self::left_ratote((*y).entry.clone(), (*y).size, &(*y).left, &*z), right))
	// 						},
	// 						_ => (),
	// 					}
	// 				},
	// 				_ => (),
	// 			}
	// 		},
	// 		_ => {
	// 			match left {
	// 				&Some(ref x) if (*x).size > 1 => return Rc::new(Self::right_ratote(e, size, &(*x), &None)),
	// 				_ => (),
	// 			}
	// 		},
	// 	};
	// 	Rc::new(Node(e, size, left.clone(), right.clone()))
	// }
	// // 右节点增加大小，Maintain操作
	// //#[inline]
	// fn maintain_right (e: Entry<K, V>, size: usize, left: &Option<Rc<Self>>, right: &Option<Rc<Self>>) -> Rc<Self> {
	// 	match left {
	// 		&Some(ref x) => {
	// 			match right {
	// 				&Some(ref y) => {
	// 					match (*y).right {
	// 						Some(ref z) if (*z).size > (*x).size => return Rc::new(Self::left_ratote(e, size, left, &(*y))),
	// 						_ => (),
	// 					};
	// 					match (*y).left {
	// 						Some(ref z) if (*z).size > (*x).size => {
	// 							return Rc::new(Self::left_ratote(e, size, left, &Self::right_ratote((*y).entry.clone(), (*y).size, &*z, &(*y).right)))
	// 						},
	// 						_ => (),
	// 					}
	// 				},
	// 				_ => (),
	// 			}
	// 		},
	// 		_ => {
	// 			match right {
	// 				&Some(ref x) if (*x).size > 1 => return Rc::new(Self::left_ratote(e, size, &None, &(*x))),
	// 				_ => (),
	// 			}
	// 		},
	// 	};
	// 	Rc::new(Node(e, size, left.clone(), right.clone()))
	// }

}

